// calc.js - Globale Definitionen

// Wechselkurs Variable global machen
window.tryDayPrice = 0.027; 

// Funktion global verfügbar machen (window.funcName)
window.fetchExchangeRate = async () => {
    try {
        const response = await fetch('https://api.exchangerate-api.com/v4/latest/TRY');
        if (!response.ok) throw new Error(`API-Anfrage fehlgeschlagen: ${response.status}`);
        const data = await response.json();
        if (data && data.rates && data.rates.EUR) {
            window.tryDayPrice = data.rates.EUR;
            console.log("Wechselkurs aktualisiert: " + window.tryDayPrice);
        }
    } catch (error) {
        console.warn("Fehler beim Laden des Wechselkurses, nutze Fallback:", error);
    }
};

// Direkt ausführen
window.fetchExchangeRate();

window.getCurrentDateTime = () => {
    const now = new Date();
    return `${String(now.getDate()).padStart(2, '0')}.${String(now.getMonth() + 1).padStart(2, '0')}.${now.getFullYear()} um ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')} Uhr`;
};

// Parameter currentParams kommt aus dem Hauptskript (Scope-Inheritance via eval)
window.determinePriceCategory = (price, category, productCount) => {
    if (!currentParams.currency) return 'Unbekannt'; 

    const numericPrice = parseFloat(price.replace(',', '.').replace('€', '').replace('TRY','').replace('₺','').trim());
    const numericCategory = parseFloat(category);
    // Zugriff auf window.tryDayPrice
    const currencyFactor = currentParams.currency === 'TRY' ? window.tryDayPrice : 1; 
    const factorBase = numericCategory * currencyFactor * productCount;

    if (isNaN(numericPrice) || isNaN(numericCategory) || factorBase <= 0) return 'Fehler'; 

    const factor = (numericPrice / factorBase).toFixed(5); 

    if (!currentParams.thresholds || currentParams.thresholds.length < 3) return 'Thresholds fehlen';

    if (factor <= currentParams.thresholds[0]) return 'Top';
    if (factor <= currentParams.thresholds[1]) return 'Gut';
    if (factor <= currentParams.thresholds[2]) return 'Okay';
    return 'Schlecht';
};

window.formatPriceForDisplay = (price, forceSymbol = null) => {
    if (typeof price !== 'number' || isNaN(price)) {
        console.error("Ungültiger Preis für Formatierung:", price);
        return "N/A";
    }
    const currencySymbol = forceSymbol ? forceSymbol : (currentParams.currency === 'TRY' ? '₺' : '€');
    let priceString = price.toFixed(2).replace('.', ','); 
    return `${priceString}${currencySymbol}`;
};

window.getOrientationText = (category, productCount) => {
    if (!currentParams.currency || !currentParams.factors || !currentParams.factors.length || currentParams.factors.length < 4) {
        return 'Parameter für Orientierung fehlen';
    }
    const numericCategory = parseFloat(category);
    if (isNaN(numericCategory)) return 'Ungültige Kategorie';
    
    const currencyFactor = currentParams.currency === 'TRY' ? window.tryDayPrice : 1;
    if (isNaN(currencyFactor)) return 'Währungsfaktor Fehler';

    const factors = currentParams.factors;
    const priceLabels = ['Top', 'Gut', 'Okay', 'Schlecht'];

    const priceTexts = factors.map((factor, index) => {
        let numericPrice;
        let label;

        if (index < 3) { 
            if (isNaN(factor)) return 'Faktor Fehler';
            numericPrice = (factor * numericCategory * productCount * currencyFactor * 100) / 100;
            label = 'bis';
        } else { 
            if (isNaN(factors[2])) return 'Faktor Fehler';
            const okayNumericPrice = (factors[2] * numericCategory * productCount * currencyFactor * 100) / 100;
            numericPrice = okayNumericPrice + 0.01; 
            label = 'ab';
        }

        let formattedPrice;
        if (isNaN(numericPrice)) {
            formattedPrice = 'N/A€';
        } else {
            const numStr = numericPrice.toString();
            const parts = numStr.split('.'); 
            if (parts.length === 1) { 
                formattedPrice = parts[0] + ',00€';
            } else { 
                const decimalPart = parts[1] || ''; 
                if (decimalPart.length === 1) { 
                    formattedPrice = parts[0] + ',' + decimalPart + '0€';
                } else { 
                    formattedPrice = parts[0] + ',' + decimalPart.substring(0, 2) + '€';
                }
            }
        }

        const priceLabel = priceLabels[index] || 'Unbekannt';
        return `<b>${priceLabel}</b> ${label} <b>${formattedPrice}</b>`;
    });

    if (priceTexts.some(text => text.includes('Fehler'))) {
        return "Fehler in Orientierungsberechnung";
    }

    return priceTexts.join(' | ');
};
